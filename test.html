<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D SLIDER SCROLL</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        overflow-x: hidden;
        background: #808080;
      }
      section {
        width: 100vw;
        height: 100vh;
        position: relative;
      }
      .intro,
      .outro {
        display: flex;
        justify-content: center;
        align-items: center;
        background: crimson;
        font-size: 3rem;
      }
      .slider {
        position: relative;
        background-color: #111;
        background-image: repeating-linear-gradient(
            to right,
            transparent 0 50px,
            #ffffff25 50px 51px
          ),
          repeating-linear-gradient(
            to bottom,
            transparent 0 50px,
            #ffffff25 50px 51px
          );
        overflow: hidden;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <section class="intro">( Intro )</section>
    <section class="slider"></section>
    <section class="outro">( Outro )</section>

    <!-- CDN -->
    <script src="https://unpkg.com/lenis@1.1.20/dist/lenis.min.js"></script>
    <script src="https://unpkg.com/gsap@3.13.0/dist/gsap.min.js"></script>
    <script src="https://unpkg.com/gsap@3.13.0/dist/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      gsap.registerPlugin(ScrollTrigger);

      document.addEventListener("DOMContentLoaded", async () => {
        // Smooth scroll
        const lenis = new Lenis();
        lenis.on("scroll", ScrollTrigger.update);
        gsap.ticker.add((time) => lenis.raf(time * 1000));

        const sliderSection = document.querySelector(".slider");

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        sliderSection.appendChild(renderer.domElement);

        // Load images for slider
        const loadImage = (num) =>
          new Promise((resolve) => {
            new THREE.TextureLoader().load(
              `assets/img${num}.jpg`,
              (tex) => resolve(tex),
              undefined,
              (err) => {
                console.warn(`Missing image img${num}.jpg`);
                resolve(null);
              }
            );
          });

        const images = await Promise.all([1, 2, 3, 4, 5, 6, 7].map(loadImage));

        // Canvas texture for cards
        const texCanvas = document.createElement("canvas");
        texCanvas.width = 4096;
        texCanvas.height = 2048;
        const ctx = texCanvas.getContext("2d");

        function drawCards(offset = 0) {
          ctx.clearRect(0, 0, texCanvas.width, texCanvas.height);
          const cardW = texCanvas.width / 3;
          const cardH = texCanvas.height / 2;
          const spacing = texCanvas.width / 2.5;
          images.forEach((img, i) => {
            if (img?.image)
              ctx.drawImage(
                img.image,
                i * spacing + (0.35 - offset) * texCanvas.width * 5 - cardW,
                (texCanvas.height - cardH) / 2,
                cardW,
                cardH
              );
          });
          cardsTex.needsUpdate = true;
        }

        const cardsTex = new THREE.CanvasTexture(texCanvas);
        cardsTex.wrapS = THREE.RepeatWrapping;
        cardsTex.wrapT = THREE.RepeatWrapping;

        const cardsMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(30, 15, 50, 1),
          new THREE.MeshBasicMaterial({
            map: cardsTex,
            side: THREE.DoubleSide,
            transparent: true,
          })
        );
        scene.add(cardsMesh);

        // Slight 3D deformation
        const positions = cardsMesh.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          positions.setZ(i, Math.pow(positions.getX(i) / 15, 2) * 7.5);
        }
        positions.needsUpdate = true;

        // Animation loop
        function animate() {
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();

        // ScrollTrigger to move cards
        ScrollTrigger.create({
          trigger: ".slider",
          start: "top top",
          end: "+=500%",
          pin: true,
          scrub: 1,
          onUpdate: (st) => drawCards(st.progress),
        });

        // Resize
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      });
    </script>
  </body>
</html>
